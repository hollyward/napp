"use strict";
/*
 * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MapProxy_1 = require("./MapProxy");
var NearCache_1 = require("../nearcache/NearCache");
var Promise = require("bluebird");
var MapAddNearCacheEntryListenerCodec_1 = require("../codec/MapAddNearCacheEntryListenerCodec");
var EntryEventType_1 = require("../core/EntryEventType");
var MapRemoveEntryListenerCodec_1 = require("../codec/MapRemoveEntryListenerCodec");
var BuildMetadata_1 = require("../BuildMetadata");
var MapAddNearCacheInvalidationListenerCodec_1 = require("../codec/MapAddNearCacheInvalidationListenerCodec");
var StaleReadDetectorImpl_1 = require("../nearcache/StaleReadDetectorImpl");
var MIN_EVENTUALLY_CONSISTENT_NEARCACHE_VERSION = BuildMetadata_1.BuildMetadata.calculateVersion('3.8');
var NearCachedMapProxy = /** @class */ (function (_super) {
    __extends(NearCachedMapProxy, _super);
    function NearCachedMapProxy(client, servicename, name) {
        var _this = _super.call(this, client, servicename, name) || this;
        _this.nearCache = new NearCache_1.NearCacheImpl(_this.client.getConfig().getNearCacheConfig(name), _this.client.getSerializationService());
        if (_this.nearCache.isInvalidatedOnChange()) {
            _this.addNearCacheInvalidationListener().then(function (id) {
                _this.invalidationListenerId = id;
            });
        }
        return _this;
    }
    NearCachedMapProxy.prototype.invalidatCacheEntryAndReturn = function (keyData, retVal) {
        this.nearCache.invalidate(keyData);
        return retVal;
    };
    NearCachedMapProxy.prototype.invalidateCacheAndReturn = function (retVal) {
        this.nearCache.clear();
        return retVal;
    };
    NearCachedMapProxy.prototype.clear = function () {
        return _super.prototype.clear.call(this).then(this.invalidateCacheAndReturn.bind(this));
    };
    NearCachedMapProxy.prototype.containsKeyInternal = function (keyData) {
        var cachedValue = this.nearCache.get(keyData);
        if (cachedValue !== undefined) {
            return Promise.resolve(cachedValue != null);
        }
        else {
            return _super.prototype.containsKeyInternal.call(this, keyData);
        }
    };
    NearCachedMapProxy.prototype.deleteInternal = function (keyData) {
        this.nearCache.invalidate(keyData);
        return _super.prototype.deleteInternal.call(this, keyData).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.evictAll = function () {
        this.nearCache.clear();
        return _super.prototype.evictAll.call(this).then(this.invalidateCacheAndReturn.bind(this));
    };
    NearCachedMapProxy.prototype.evictInternal = function (key) {
        return _super.prototype.evictInternal.call(this, key).then(this.invalidatCacheEntryAndReturn.bind(this, key));
    };
    NearCachedMapProxy.prototype.putAllInternal = function (partitionsToKeysData) {
        var _this = this;
        return _super.prototype.putAllInternal.call(this, partitionsToKeysData).then(function () {
            for (var partition in partitionsToKeysData) {
                partitionsToKeysData[partition].forEach(function (entry) {
                    _this.nearCache.invalidate(entry[0]);
                });
            }
        });
    };
    NearCachedMapProxy.prototype.removeNearCacheInvalidationListener = function () {
        return this.client.getListenerService().deregisterListener(this.invalidationListenerId);
    };
    NearCachedMapProxy.prototype.postDestroy = function () {
        var _this = this;
        return this.removeNearCacheInvalidationListener().then(function () {
            _this.client.getRepairingTask().deregisterHandler(_this.name);
        }).then(function () {
            return _super.prototype.postDestroy.call(_this);
        });
    };
    NearCachedMapProxy.prototype.putIfAbsentInternal = function (keyData, valueData, ttl) {
        return _super.prototype.putIfAbsentInternal.call(this, keyData, valueData, ttl).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.putTransientInternal = function (keyData, valueData, ttl) {
        return _super.prototype.putTransientInternal.call(this, keyData, valueData, ttl).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.executeOnKeyInternal = function (keyData, proData) {
        return _super.prototype.executeOnKeyInternal.call(this, keyData, proData).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.putInternal = function (keyData, valueData, ttl) {
        return _super.prototype.putInternal.call(this, keyData, valueData, ttl).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.getInternal = function (keyData) {
        var _this = this;
        var cachedValue = this.nearCache.get(keyData);
        if (cachedValue !== undefined) {
            return Promise.resolve(cachedValue);
        }
        else {
            var reservation_1 = this.nearCache.tryReserveForUpdate(keyData);
            return _super.prototype.getInternal.call(this, keyData).then(function (val) {
                _this.nearCache.tryPublishReserved(keyData, val, reservation_1);
                return val;
            }).catch(function (err) {
                throw err;
            });
        }
    };
    NearCachedMapProxy.prototype.tryRemoveInternal = function (keyData, timeout) {
        return _super.prototype.tryRemoveInternal.call(this, keyData, timeout).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.removeInternal = function (keyData, value) {
        return _super.prototype.removeInternal.call(this, keyData, value).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.getAllInternal = function (partitionsToKeys, result) {
        var _this = this;
        if (result === void 0) { result = []; }
        try {
            for (var partition in partitionsToKeys) {
                var partitionArray = partitionsToKeys[partition];
                for (var i = partitionArray.length - 1; i >= 0; i--) {
                    var key = partitionArray[i];
                    var cachedResult = this.nearCache.get(key);
                    if (cachedResult !== undefined) {
                        result.push([this.toObject(partitionArray[i]), cachedResult]);
                        partitionArray = partitionArray.splice(i, 1);
                    }
                }
            }
        }
        catch (err) {
            return Promise.resolve([]);
        }
        var reservations = [];
        for (var partition in partitionsToKeys) {
            var partitionArray = partitionsToKeys[partition];
            for (var i = 0; i < partitionArray.length; i++) {
                var key = partitionArray[i];
                reservations.push(this.nearCache.tryReserveForUpdate(key));
            }
        }
        return _super.prototype.getAllInternal.call(this, partitionsToKeys, result).then(function (serializedEntryArray) {
            serializedEntryArray.forEach(function (serializedEntry, index) {
                var key = serializedEntry[0];
                var value = serializedEntry[1];
                _this.nearCache.tryPublishReserved(key, value, reservations[index]);
            });
            return result;
        });
    };
    NearCachedMapProxy.prototype.replaceIfSameInternal = function (keyData, oldValueData, newValueData) {
        return _super.prototype.replaceIfSameInternal.call(this, keyData, oldValueData, newValueData)
            .then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.replaceInternal = function (keyData, valueData) {
        return _super.prototype.replaceInternal.call(this, keyData, valueData).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.setInternal = function (keyData, valueData, ttl) {
        return _super.prototype.setInternal.call(this, keyData, valueData, ttl).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.tryPutInternal = function (keyData, valueData, timeout) {
        return _super.prototype.tryPutInternal.call(this, keyData, valueData, timeout)
            .then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.addNearCacheInvalidationListener = function () {
        var codec = this.createInvalidationListenerCodec(this.name, EntryEventType_1.EntryEventType.INVALIDATION);
        if (this.supportsRepairableNearCache()) {
            return this.client.getListenerService().registerListener(codec, this.createNearCacheEventHandler());
        }
        else {
            return this.client.getListenerService().registerListener(codec, this.createPre38NearCacheEventHandler());
        }
    };
    NearCachedMapProxy.prototype.createInvalidationListenerCodec = function (name, flags) {
        if (this.supportsRepairableNearCache()) {
            return {
                encodeAddRequest: function (localOnly) {
                    return MapAddNearCacheInvalidationListenerCodec_1.MapAddNearCacheInvalidationListenerCodec.encodeRequest(name, flags, localOnly);
                },
                decodeAddResponse: function (msg) {
                    return MapAddNearCacheInvalidationListenerCodec_1.MapAddNearCacheInvalidationListenerCodec.decodeResponse(msg).response;
                },
                encodeRemoveRequest: function (listenerId) {
                    return MapRemoveEntryListenerCodec_1.MapRemoveEntryListenerCodec.encodeRequest(name, listenerId);
                }
            };
        }
        else {
            return {
                encodeAddRequest: function (localOnly) {
                    return MapAddNearCacheEntryListenerCodec_1.MapAddNearCacheEntryListenerCodec.encodeRequest(name, flags, localOnly);
                },
                decodeAddResponse: function (msg) {
                    return MapAddNearCacheEntryListenerCodec_1.MapAddNearCacheEntryListenerCodec.decodeResponse(msg).response;
                },
                encodeRemoveRequest: function (listenerId) {
                    return MapRemoveEntryListenerCodec_1.MapRemoveEntryListenerCodec.encodeRequest(name, listenerId);
                }
            };
        }
    };
    NearCachedMapProxy.prototype.supportsRepairableNearCache = function () {
        return this.getConnectedServerVersion() >= MIN_EVENTUALLY_CONSISTENT_NEARCACHE_VERSION;
    };
    NearCachedMapProxy.prototype.createPre38NearCacheEventHandler = function () {
        var nearCache = this.nearCache;
        var handle = function (keyData) {
            if (keyData == null) {
                nearCache.clear();
            }
            else {
                nearCache.invalidate(keyData);
            }
        };
        var handleBatch = function (keys) {
            keys.forEach(function (key) {
                nearCache.invalidate(key);
            });
        };
        return function (m) {
            MapAddNearCacheEntryListenerCodec_1.MapAddNearCacheEntryListenerCodec.handle(m, handle, handleBatch);
        };
    };
    NearCachedMapProxy.prototype.createNearCacheEventHandler = function () {
        var repairingTask = this.client.getRepairingTask();
        var repairingHandler = repairingTask.registerAndGetHandler(this.getName(), this.nearCache);
        var staleReadDetector = new StaleReadDetectorImpl_1.StaleReadDetectorImpl(repairingHandler, this.client.getPartitionService());
        this.nearCache.setStaleReadDetector(staleReadDetector);
        var handle = function (key, sourceUuid, partitionUuid, sequence) {
            repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);
        };
        var handleBatch = function (keys, sourceUuids, partititonUuids, sequences) {
            repairingHandler.handleBatch(keys, sourceUuids, partititonUuids, sequences);
        };
        return function (m) {
            MapAddNearCacheInvalidationListenerCodec_1.MapAddNearCacheInvalidationListenerCodec.handle(m, handle, handleBatch);
        };
    };
    return NearCachedMapProxy;
}(MapProxy_1.MapProxy));
exports.NearCachedMapProxy = NearCachedMapProxy;
//# sourceMappingURL=NearCachedMapProxy.js.map